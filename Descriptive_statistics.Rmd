---
title: "Descriptive statistics"
author: "Mathilda Alhamadah"
date: "2025-06-17"
output:
  html_document:
    toc: true             #table des matières
    toc_float: true       #table des matières toujours visible
    theme: bootstrap      #changer le thème de la page
    highlight: zenburn    #changer le thème des chunks
    
editor_options: 
  markdown: 
    wrap: 80
---

```{r packages_and_data, message=FALSE, warning=FALSE}

#Packages
library(jsonlite)
library(purrr)
library(curl)
library(dplyr)
library(lubridate)
library(tidyr)
library(ggplot2)
library(patchwork)
library(tidyverse)
library(ggpubr)
library(rstatix)



#Data
load("data_04_to_12_07_2022.Rdata") #load all data between 04 & 12 of July
rm(list = setdiff(ls(), c("data_04_to_12_07_2022"))) #remove useless data
```

# Consistency of the certainty distribution

## Confidence depending on the number of predictions

Original data :

```{r}
# Highest confidence rate depending on the number of predictions

# New dataset with the number of predictions as a factor variable
data_group_number_pred <- data_04_to_12_07_2022 %>%
  mutate(group = as.factor(number_of_predictions))

# New dataset with a variable "group" always being "All"
data_group_overall <- data_04_to_12_07_2022 %>%
  mutate(group = "Total")

# Merge the 2 datasets into 1 (so it's 2 times bigger)
merged_data <- bind_rows(data_group_number_pred, data_group_overall)

# Display boxplots
ggplot(merged_data, aes(x = group, y = confidence, fill = group)) +
  geom_boxplot() +
  xlab("Amount of predictions made for 1 frame (and total)") +
  ylab("Highest confidence of the prediction for 1 frame") +
  theme(legend.position = "right") +
  ggtitle("Data from 04/07/2022 to 12/07/2022",
          subtitle = "With all the data")


# Clean up
rm(data_group_number_pred, data_group_overall, merged_data)

```

Data between 8h and 21h only :

```{r}
# Highest confidence rate depending on the number of predictions

load("data_8h_21h_04_to_12_07_2022.Rdata")

# New dataset with the number of predictions as a factor variable
data_group_number_pred <- data_8h_21h_04_to_12_07_2022 %>%
  mutate(group = as.factor(number_of_predictions))

# New dataset with a variable "group" always being "All"
data_group_overall <- data_8h_21h_04_to_12_07_2022 %>%
  mutate(group = "Total")

# Merge the 2 datasets into 1 (so it's 2 times bigger)
merged_data <- bind_rows(data_group_number_pred, data_group_overall)

# Display boxplots
ggplot(merged_data, aes(x = group, y = confidence, fill = group)) +
  geom_boxplot() +
  xlab("Amount of predictions made for 1 frame (and total)") +
  ylab("Highest confidence of the prediction for 1 frame") +
  theme(legend.position = "right") +
  ggtitle("Data from 04/07/2022 to 12/07/2022",
          subtitle = "Only with the 8h-21h data")

# Clean up
rm(data_group_number_pred, data_group_overall, merged_data)
```

=\> Changes nothing with or without the data that is not between 8h and 21h.

Anyways, we were forced to remove them because with the data corruption there
were not enough data outside this range to keep it. And we also did this because
we had to make the days homogeneous so that we can stick them together and skip
the majority of the missing part.

So we won't use these boxplots to prove that we did a good choice because we
were forced to do this. But we can use it to suggest that if we had complete
data, maybe the confidence distribution won't change since adding or not data
between 8-21h didn't change its distribution.

But idk if it's true because the missing data contains a big part of night, so
maybe certainty won't be the same (less certainty).

Let's do a test to see if the difference is true. Why running an ANOVA ? → Cf
part "confidence_gap".

```{r}
par(mfrow = c(3, 2))

# When 1 prediction
hist((data_8h_21h_04_to_12_07_2022 %>% 
       filter(number_of_predictions == 1) %>% #when 1 prediction made
       select(confidence)                     #get the confidence
      )[[1]],                                 #only 1st object of the output
     main = "Confidence when 1 prediction",
     xlab = "Values of confidence",
     ylab = "Count",
     col = "chartreuse3",
     freq = TRUE)

# When 2 predictions
hist((data_8h_21h_04_to_12_07_2022 %>% 
       filter(number_of_predictions == 2) %>% #when 2 predictions made
       select(confidence)                     #get the confidence
      )[[1]],                                 #only 1st object of the output
     main = "Confidence when 2 predictions",
     xlab = "Values of confidence",
     ylab = "Count",
     col = "gold",
     freq = TRUE)

# When 3 predictions
hist((data_8h_21h_04_to_12_07_2022 %>% 
       filter(number_of_predictions == 3) %>% #when 3 predictions made
       select(confidence)                     #get the confidence
      )[[1]],                                 #only 1st object of the output
     main = "Confidence when 3 predictions",
     xlab = "Values of confidence",
     ylab = "Count",
     col = "orange",
     freq = TRUE)


# When 4 predictions
hist((data_8h_21h_04_to_12_07_2022 %>% 
       filter(number_of_predictions == 4) %>% #when 4 predictions made
       select(confidence)                     #get the confidence
      )[[1]],                                 #only 1st object of the output
     main = "Confidence when 4 predictions",
     xlab = "Values of confidence",
     ylab = "Count",
     col = "firebrick2",
     freq = TRUE)


# Overall distribution
hist((data_8h_21h_04_to_12_07_2022 %>% 
       select(confidence)                     #get the confidence
      )[[1]],                                 #only 1st object of the output
     main = "Overall confidence distribution",
     xlab = "Values of confidence",
     ylab = "Count",
     col = "lightblue",
     freq = TRUE)


```

Kruskal-Wallis (comparison of ranks) to see if the confidence differs
significantly between the groups (groups = number of predictions made by YOLO) :

```{r}
# Few data with 5 predictions : remove them
data_less_5pred <- data_8h_21h_04_to_12_07_2022 %>% 
  filter(number_of_predictions < 5) %>% 
  select(number_of_predictions, confidence)

# Kruskal Wallis because non normal distributions & more than 2 groups
kruskal.test(data_less_5pred$confidence ~ data_less_5pred$number_of_predictions)

rm(data_less_5pred)
```

There is a confidence difference between groups (p=10\^-16).

## Confidence gap depending on the number of predictions

```{r}
# Confidence gap depending on the number of predictions

# New dataset with the number of predictions as a factor variable
data_group_number_pred <- data_8h_21h_04_to_12_07_2022 %>%
  filter(number_of_predictions >= 2 & number_of_predictions <= 4) %>% 
  mutate(group = as.factor(number_of_predictions))

# New dataset with a variable "group" always being "All"
data_group_overall <- data_04_to_12_07_2022 %>%
  mutate(group = "Total")

# Merge the 2 datasets into 1 (so it's 2 times bigger)
merged_data <- bind_rows(data_group_number_pred, data_group_overall)

# Display boxplots
ggplot(merged_data, aes(x = group, y = confidence_gap, fill = group)) +
  geom_boxplot() +
  xlab("Amount of predictions made for 1 frame (and total)") +
  ylab("Confidence gap between the 2 highest predictions of a frame") +
  theme(legend.position = "right") +
  ggtitle("Data from 04/07/2022 to 12/07/2022",
          subtitle = "With all the data")


# Clean up
rm(data_group_number_pred, data_group_overall, merged_data)
```

→ So we can see that frames with 3 or 4 predictions have a lowest difference
between the confidences of the 2 most likely predictions than the frames with
only 2 predictions. So having more than 2 predictions can be linked to an
inferior discrimination of the likely postures, which seems normal.

Additional remark : it was the same boxplots with or without data outside the
range 8h-21h so no problem on this side.

Let's do a test to confirm that. Confidence_gap is a quantitative variable, and
there is more than 30 observations. We want to compare more than 2 groups (3
groups : 2, 3 and 4 predictions made). Samples are considered independent,
because a frame can't have 2 and 3 predictions at the same time (so the groups
are exclusive), and because we assume that the confidence of a frame isn't
determined by the others'. We want to run an ANOVA :

```{r}
# Confidence gap, on data 8h-21h

par(mfrow = c(2, 2))

# When 2 predictions
hist((data_8h_21h_04_to_12_07_2022 %>% 
       filter(number_of_predictions == 2) %>% #when 2 predictions made
       select(confidence_gap)                     #get the confidence
      )[[1]],                                 #only 1st object of the output
     main = "Confidence when 2 predictions",
     xlab = "Values of confidence",
     ylab = "Count",
     col = "gold",
     freq = TRUE)

# When 3 predictions
hist((data_8h_21h_04_to_12_07_2022 %>% 
       filter(number_of_predictions == 3) %>% #when 3 predictions made
       select(confidence_gap)                     #get the confidence
      )[[1]],                                 #only 1st object of the output
     main = "Confidence when 3 predictions",
     xlab = "Values of confidence",
     ylab = "Count",
     col = "orange",
     freq = TRUE)


# When 4 predictions
hist((data_8h_21h_04_to_12_07_2022 %>% 
       filter(number_of_predictions == 4) %>% #when 4 predictions made
       select(confidence_gap)                     #get the confidence
      )[[1]],                                 #only 1st object of the output
     main = "Confidence when 4 predictions",
     xlab = "Values of confidence",
     ylab = "Count",
     col = "firebrick2",
     freq = TRUE)


# Overall distribution when more than 1 prediction (otherwise : nonsense)
hist((data_8h_21h_04_to_12_07_2022 %>% 
       filter(number_of_predictions > 1) %>%  #when >1 prediction made
       select(confidence_gap)                 #get the confidence
      )[[1]],                                 #only 1st object of the output
     main = "Overall confidence distribution",
     xlab = "Values of confidence",
     ylab = "Count",
     col = "lightblue",
     freq = TRUE)

```

Mann-Whitney (comparison of ranks) : because 2 groups & non normal data

```{r}
# Test of confidence_gap differences between groups (only 2 & 3 predictions)

group1 <- (data_8h_21h_04_to_12_07_2022 %>% #2 pred
  filter(number_of_predictions == 2) %>% 
  select(confidence_gap))[[1]]

group2 <- (data_8h_21h_04_to_12_07_2022 %>% #3 pred
  filter(number_of_predictions == 3) %>%
  select(confidence_gap))[[1]]

# Mann-Whitney 
wilcox.test(group1, group2, exact = FALSE)

rm(group1, group2) #clean up
```

p\<10\^-16 : there is a difference between confidences in groups of 2 & 3
predictions.

# Comparison with or without no reliable predictions

## 1. Amount of time spent in postures : same distribution

### Functions :

```{r}
library(jsonlite)
library(purrr)
library(curl)
library(dplyr)
library(lubridate)
library(tidyr)
library(ggplot2)
library(patchwork)



# Frequency of postures lying/ sitting/ standing by timestep (chosen)

frequency_position <- function(data, interval_seconds) {
  data <- data %>% arrange(Date_Time) #sort by date
  
  start_time <- min(data$Date_Time)   #oldest frame
  end_time <- max(data$Date_Time)     #newest frame
  
  #cut between these 2 frames depending on the time interval
  intervals <- seq(from = start_time, to = end_time, by = interval_seconds)
  
  df_counts <- data.frame(                       #create the new df
    start_time = intervals[-length(intervals)],  #drop the last time
    end_time = intervals[-1]                     #drop the first time
  )
  
  df_counts <- df_counts %>%
    rowwise() %>%               #for each line
    mutate(
      lying = sum(data$Date_Time >= start_time & data$Date_Time < end_time & data$class_id == 0),            #count lying
      standing = sum(data$Date_Time >= start_time & data$Date_Time < end_time & data$class_id == 1),            #count standing
      sitting = sum(data$Date_Time >= start_time & data$Date_Time < end_time & data$class_id == 2),            #count sitting
      not_visible = sum(data$Date_Time >= start_time & data$Date_Time < end_time & data$class_id == 3)             #count not visible
    )
  
  return(df_counts)
}



# Pivot the data : 4 lines/time unit

pivot_data <- function(data,
                       variables_to_drop,       #useless variables
                       variables_to_merge,      #variables we want to merge into 1 var
                       str_name_merged_labels,  #column of the former colnames : rename
                       str_name_merged_values){  #column of the former values : rename
  
  data <- data %>% 
    select (-{{variables_to_drop}}) %>%   #eg : column end_time
    pivot_longer(
      cols = {{variables_to_merge}},      #eg : all the columns except start_time
      names_to = str_name_merged_labels,  #eg : "Posture" for the former lying/standing/...
      values_to = str_name_merged_values  #eg : "Count" for the former amounts of lying/...
    )
} 

  #Remove data between 21h-8h

filter_8h_21h <- function(data, time_column){
  data <- data %>% 
    filter(hour({{time_column}}) >= 8 & hour({{time_column}}) < 21)
  return(data)
}



add_compressed_time_variable_PIVOT_data <- function(data) {
  data$compressed_time <- rep(seq_len(nrow(data)/4)-1, each = 4)
  return(data)
}


```

### All data :

```{r}
load("data_8h_21h_04_to_12_07_2022.Rdata")

# Test for 900 seconds (15 minutes)

frequency_position_04_to_12_07_2022 <- frequency_position(data = data_8h_21h_04_to_12_07_2022, interval_seconds = 900)


frequency_position_04_to_12_07_2022_PIVOT <- frequency_position_04_to_12_07_2022[,-2] %>% #drop the end_time column
  pivot_longer(
    cols = !start_time, 
    names_to = "Posture", 
    values_to = "Count"
  )


frequency_position_04_to_12_07_2022_PIVOT <- pivot_data(data = frequency_position_04_to_12_07_2022,
                   variables_to_drop = end_time,
                   variables_to_merge = c(lying, standing, sitting, not_visible),
                   str_name_merged_labels = "Posture",
                   str_name_merged_values = "Count")

 # Test
frequency_position_8h_21h_04_to_12_07_2022_PIVOT <- filter_8h_21h(frequency_position_04_to_12_07_2022_PIVOT, start_time)

rm(frequency_position_04_to_12_07_2022_PIVOT)  #remove data with the 21h-8h gap


# Test

frequency_position_8h_21h_04_to_12_07_2022_PIVOT_compressed_time <- add_compressed_time_variable_PIVOT_data(frequency_position_8h_21h_04_to_12_07_2022_PIVOT)



#remove useless data : no compressed time
rm(frequency_position_8h_21h_04_to_12_07_2022_PIVOT)
```

### Only reliable data :

```{r}
#Load data
reliable_data_8h_21h_04_to_12_07_2022 <- data_8h_21h_04_to_12_07_2022 %>% 
           #if only 1 prediction : keep only data with a confidence >= 0.34
  filter((number_of_predictions == 1 & confidence >= 0.34) | 
           #if >1 predictions : keep only data with  a confidence >= 0.34 & a gap >0.2 between the 2 best predictions' confidences
           (number_of_predictions >1 & confidence >= 0.34 & confidence_gap >= 0.2) |
           #keep the NA values also
           is.na(confidence_gap))

#Calculate frequency position
reliable_frequency_position_04_to_12_07_2022 <- frequency_position(data = reliable_data_8h_21h_04_to_12_07_2022, interval_seconds = 900)

#Pivot data
reliable_frequency_position_04_to_12_07_2022_PIVOT <- reliable_frequency_position_04_to_12_07_2022[,-2] %>% #drop the end_time column
  pivot_longer(
    cols = !start_time, 
    names_to = "Posture", 
    values_to = "Count"
  )

#Remove data outside 8h-21h range
reliable_frequency_position_8h_21h_04_to_12_07_2022_PIVOT <- filter_8h_21h(reliable_frequency_position_04_to_12_07_2022_PIVOT, start_time)

rm(reliable_frequency_position_04_to_12_07_2022_PIVOT)  #remove data with the 21h-8h gap

#Add compressed time variable
reliable_frequency_position_8h_21h_04_to_12_07_2022_PIVOT_compressed_time <- add_compressed_time_variable_PIVOT_data(reliable_frequency_position_8h_21h_04_to_12_07_2022_PIVOT)

#remove useless data : no compressed time
rm(reliable_frequency_position_8h_21h_04_to_12_07_2022_PIVOT)


```

```{r}
library(gridExtra)

# With unreliable predictions
plot1 <- ggplot(frequency_position_8h_21h_04_to_12_07_2022_PIVOT_compressed_time, aes(x = Posture, y = Count, fill = Posture)) +
  geom_boxplot() +
  xlab("Posture") +
  ylab("Nombre d'occurences toutes les 15 minutes") +
  theme(legend.position = "right")

# Without unreliable predictions
plot2 <- ggplot(reliable_frequency_position_8h_21h_04_to_12_07_2022_PIVOT_compressed_time, aes(x = Posture, y = Count, fill = Posture)) +
  geom_boxplot() +
  xlab("Posture") +
  ylab("Nombre d'occurences toutes les 15 minutes") +
  theme(legend.position = "right")

grid.arrange(plot1, plot2, ncol=2)
```

## 2. Indicator 1 : same distribution

### All data

```{r}
# Chart for count
ggplot(data = frequency_position_8h_21h_04_to_12_07_2022_PIVOT_compressed_time,
       aes(fill = Posture, y = Count, x = compressed_time)) +         #start_time as x variable
  geom_bar(position = "stack", stat = "identity") +              #stacked bars, no %
  ggtitle("Fox4313's posture every 15min between days 04/07/2022 and 06/07/2022",
          subtitle = "With all data") +   #title
  xlab("Cumulative time between 8h and 21h each day") +
  ylab("Amount of seconds spent in each posture") +                              
  scale_fill_manual(breaks = c("lying", "sitting", "standing", "not_visible"), #re-order legend
                    values = c("lying" = "chartreuse3", #change legend colors
                               "sitting" = "orange",
                               "standing" = "tomato",
                               "not_visible" = "lightgrey"))
```

### Only reliable data

```{r}
# Chart for count
ggplot(data = reliable_frequency_position_8h_21h_04_to_12_07_2022_PIVOT_compressed_time,
       aes(fill = Posture, y = Count, x = compressed_time)) +         #start_time as x variable
  geom_bar(position = "stack", stat = "identity") +              #stacked bars, no %
  ggtitle("Fox4313's posture every 15min between days 04/07/2022 and 06/07/2022",
          subtitle = "Without non-reliable data") +   #title
  xlab("Cumulative time between 8h and 21h each day") +
  ylab("Amount of seconds spent in each posture") +                              
  scale_fill_manual(breaks = c("lying", "sitting", "standing", "not_visible"), #re-order legend
                    values = c("lying" = "chartreuse3", #change legend colors
                               "sitting" = "orange",
                               "standing" = "tomato",
                               "not_visible" = "lightgrey"))
```

## 3. Indicator 2 : same distribution

### Functions

```{r}
# All data
library(jsonlite)
library(purrr)
library(curl)
library(dplyr)
library(lubridate)
library(tidyr)
library(ggplot2)
library(patchwork)

load("data_8h_21h_04_to_12_07_2022.Rdata")

#Change posture code to lying-sitting-standing (instead of lying-standing-sitting)
posture_123 <- function(data){
  data <- data %>% 
  mutate(increasing_code = case_when(name=="lying" ~ 1,
                                   name=="sitting" ~ 2,
                                   name=="standing" ~ 3,
                                   name=="not visible" ~ NA, #to avoid having it in the sum
                                   TRUE ~ NA))
}

# Amount activity function
amount_activity <- function(data, interval_seconds) {
  data <- data %>% arrange(Date_Time)
  
  start_time <- min(data$Date_Time)
  end_time <- max(data$Date_Time)
  
  intervals <- seq(from = start_time, to = end_time, by = interval_seconds)
  
  df_counts <- data.frame(
    interval_start = intervals[-length(intervals)],
    interval_end = intervals[-1]
  )
  
  df_counts <- df_counts %>%
    rowwise() %>%
    mutate(
      total_activity =
        sum(data$increasing_code[data$Date_Time >= interval_start
                                 & data$Date_Time < interval_end],
            na.rm = TRUE)/3, #divide by 3 because max score = 3 : get a max to 1
      activity_proportion = ifelse(
        total_activity != 0,
        (total_activity) / nrow(data[data$Date_Time >= interval_start & data$Date_Time < interval_end, ]), #divided by 3 because score max = 3
        0
      )
    )
  
  return(df_counts)
}

# Function to remove the 21h-8h gap that has been re-created by the amount_activity function
filter_8h_21h <- function(data, time_column){
  data <- data %>% 
    filter(hour({{time_column}}) >= 8 & hour({{time_column}}) < 21)
  return(data)
}

# Useful to skip the 21h-8h gap when plotting/ analyzing
add_compressed_time_variable <- function(data) {
  data$compressed_time <- seq_len(nrow(data))-1 #-1 to make it start with 0
  return(data)
}

## Get the areas we want to color

get_areas_color <- function(data, times_vector_xmin, times_vector_xmax, fill) {
  # S'assurer que le vecteur de temps est au format POSIXct
  times_vector_xmin <- as.POSIXct(times_vector_xmin)
  times_vector_xmax <- as.POSIXct(times_vector_xmax)

  # Initialiser le vecteur de résultats
  result_min <- vector("numeric", length(times_vector_xmin))
  result_max <- vector("numeric", length(times_vector_xmax))

  # Pour chaque temps, trouver la ligne correspondante
  for (i in seq_along(times_vector_xmin)) {
    time_min <- times_vector_xmin[i]
    matched_row_min <- data %>%
      filter(interval_start <= time_min & interval_end >= time_min)

    # Si une ligne correspond, extraire compressed_time
    if (nrow(matched_row_min) > 0) {
      result_min[i] <- matched_row_min$compressed_time[1]
    } else {
      result_min[i] <- NA  # Aucun match trouvé
    }
  }

  # Pour chaque temps, trouver la ligne correspondante
  for (i in seq_along(times_vector_xmax)) {
    time_max <- times_vector_xmax[i]
    matched_row_max <- data %>%
      filter(interval_start <= time_max & interval_end >= time_max)

    # Si une ligne correspond, extraire compressed_time
    if (nrow(matched_row_max) > 0) {
      result_max[i] <- matched_row_max$compressed_time[1]
    } else {
      result_max[i] <- NA  # Aucun match trouvé
    }
  }  
  
  df_areas <- data.frame(xmin = result_min, xmax = result_max, fill = fill)
  
  return(df_areas)
}

## Plot 

plot_activity_with_areas <- function(data, nb_min, areas,
                                     title, subtitle,
                                     x_lab, y_lab) {

  # Créer le plot
  ggplot(data, aes(x = compressed_time, y = activity_proportion)) +
    geom_rect(data = areas,
              aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf, fill = fill),
              inherit.aes = FALSE, alpha = 0.2) +
    geom_line() +
    ylab(y_lab) +
    scale_x_continuous(name = x_lab,
                       breaks = seq(from = 0, to = nrow(data), by = 10)) +
    ggtitle(title,
            subtitle = paste(subtitle, "every", nb_min, "minutes."))
}

## From load to plot

from_data_to_plot <- function(data_8h_21h,
                              interval_seconds,
                              time_column = interval_start,
                              title,
                              subtitle,
                              x_lab,
                              y_lab){
  
  data_8h_21h_increasing_code <- posture_123(data_8h_21h)

  amount_activity_data <- amount_activity(data = data_8h_21h_increasing_code,
                                     interval_seconds = interval_seconds) # default = 900 seconds (15 minutes)

# remove the 21h-8h gap
  amount_activity_8h_21h <- filter_8h_21h(
    data = amount_activity_data,
    time_column = interval_start)


  # Compressed time variable to skip parts between 21h and 8h
  amount_activity_x_minutes_8h_21h_compressed_time <- add_compressed_time_variable(amount_activity_8h_21h)

  areas <- get_areas_color(data = amount_activity_x_minutes_8h_21h_compressed_time,
                            times_vector_xmin =
                              c("2022-07-04 08:00:00", #No data
                                "2022-07-04 18:57:00",
                                "2022-07-05 18:57:00",
                                "2022-07-04 10:47:00", #Inactive
                                "2022-07-04 13:17:00",
                                "2022-07-05 08:13:00",
                                "2022-07-06 08:50:00",
                                "2022-07-04 17:07:00", #Active
                                "2022-07-05 09:13:00",
                                "2022-07-06 09:50:00",
                                "2022-07-04 11:56:00"),#Out for implant
                            times_vector_xmax = 
                              c("2022-07-04 10:47:00", #No data
                                "2022-07-05 08:13:00",
                                "2022-07-06 08:50:00",
                                "2022-07-04 11:56:00", #Inactive
                                "2022-07-04 15:08:00",
                                "2022-07-05 09:13:00",
                                "2022-07-06 09:50:00",
                                "2022-07-04 18:57:00", #Active
                                "2022-07-05 10:22:00",
                                "2022-07-06 12:31:00",
                                "2022-07-04 13:17:00"),#Out for implant
                            fill =
                              c("No data", "No data", "No data",
                                "Inactive", "Inactive", "Inactive", "Inactive",
                                "Active", "Active", "Active",
                                "Out for implant"))
  
  plot <- plot_activity_with_areas(
    amount_activity_x_minutes_8h_21h_compressed_time,
    nb_min = interval_seconds/60,
    areas = areas,
    title = title,
    subtitle = subtitle,
    x_lab = x_lab,
    y_lab = y_lab)
  
  return(plot)

  }
```

### All data

```{r}
from_data_to_plot(data_8h_21h = data_8h_21h_04_to_12_07_2022,
                  interval_seconds = 3600,
                  title = "Posture's score of fox 4313",
                  subtitle = "With all data, from 04/07/2022 to 12/07/2022",
                  x_lab = "Cumulative time of the day (only between 8h and 21h)",
                  y_lab = "Movement score by summing posture indices")
```

### Only reliable data

```{r}
reliable_data_8h_21h_04_to_12_07_2022 <- data_8h_21h_04_to_12_07_2022 %>% 
           #if only 1 prediction : keep only data with a confidence >= 0.34
  filter((number_of_predictions == 1 & confidence >= 0.34) | 
           #if >1 predictions : keep only data with  a confidence >= 0.34 & a gap >0.2 between the 2 best predictions' confidences
           (number_of_predictions >1 & confidence >= 0.34 & confidence_gap >= 0.2) |
           #keep the NA values also
           is.na(confidence_gap))

from_data_to_plot(data_8h_21h = reliable_data_8h_21h_04_to_12_07_2022,
                  interval_seconds = 3600,
                  title = "Posture's score of fox 4313",
                  subtitle = "Without non-reliable data, from 04/07/2022 to 12/07/2022",
                  x_lab = "Cumulative time of the day (only between 8h and 21h)",
                  y_lab = "Movement score by summing posture indices")
```

```{r}
grid.arrange(from_data_to_plot(data_8h_21h = data_8h_21h_04_to_12_07_2022,
                  interval_seconds = 3600), 
             from_data_to_plot(data_8h_21h = reliable_data_8h_21h_04_to_12_07_2022,
                  interval_seconds = 3600),
             ncol=2)
```

## 4. Indicator 3 :

### Functions

```{r}
library(jsonlite)
library(purrr)
library(curl)
library(dplyr)
library(lubridate)
library(tidyr)
library(ggplot2)
library(patchwork)
```

```{r}
load("data_8h_21h_04_to_12_07_2022.Rdata")
```

```{r}
#Function 1 : detect time changes

amount_posture_changes <- function(
    data,
    group_time){ #group_time : "number + unit" (among : second, minute, hour, day,                     week, month, bimonth, quarter, season, halfyear and year)
  
  # Temporary variable : not_visible & NAs replaced by NAs
  data <- data %>% 
    mutate(posture_no_NA = case_when(
      name == "not visible" ~ NA,  #NA if not visible
      is.na(name) ~ NA,            #NA if NA
      TRUE ~ name)                 #else : posture name
      )  
  
  data <- data %>%
    fill(posture_no_NA)           #refill NAs (= real NAs + not_visible) with latest posture seen
  
  
  # Detect position changes
  data_valid <- data %>%
    arrange(Date_Time) %>%  #Sort by date
    # Movement : if posture != posture at previous time (skip NAs & not_visible)
    mutate(Position_change = posture_no_NA != lag(posture_no_NA, default = first(posture_no_NA)))

  # Results
  return(changes_by_group_time(data_valid, time_gap = group_time))
  }



# Function 2 : Get the sum of posture changes by time unit

changes_by_group_time <- function(data, time_gap) {
  data %>%
    mutate(Time_group = floor_date(Date_Time, unit = time_gap)) %>% #make time groups
    group_by(Time_group) %>%
    summarise(Nb_changes = sum(Position_change, na.rm = TRUE)) %>% #sum changes
    ungroup()                                     #just in case
}


# Function 3 : add a new time variable to replace the real time

add_compressed_time_variable <- function(data) {
  data$compressed_time <- seq_len(nrow(data))-1
  return(data)
}

# Areas to color

#blue : no data available (corrupted videos)
#purple : out of the cage to put him the implant
#red : active
#green : inactive

areas <- data.frame(
  xmin = c(0, 43, 96,
           11, 21, 53, 109,
           36, 57, 113,
           15),
  xmax = c(11, 53, 109,
           15, 28, 57, 113,
           43, 62, 124,
           21),
  fill = c("No data", "No data", "No data",
           "Inactive", "Inactive", "Inactive", "Inactive",
           "Active", "Active", "Active",
           "Out for implant")
)
```

### All data

```{r}
# Changes per 15minutes & per day
amount_changes_data_8h_21h_04_to_12_07_2022 <- amount_posture_changes(data_8h_21h_04_to_12_07_2022, "15 minute")

# Skip parts between 21h and 8h
amount_changes_data_8h_21h_04_to_12_07_2022_compressed_time <- add_compressed_time_variable(amount_changes_data_8h_21h_04_to_12_07_2022)

# Plot
ggplot(amount_changes_data_8h_21h_04_to_12_07_2022_compressed_time,
       aes(x = compressed_time, y = Nb_changes)) +
  
  geom_rect(data = areas, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf, fill = fill),
            inherit.aes = FALSE, alpha = 0.2) +
  
  geom_line() +
  #xlab("Temps entre 8h et 21h chaque jour") +
  ylab("Amount of posture changes") +
  ggtitle("Posture changes of fox 4313", subtitle = "All data, from 04/07/2022 to 12/07/2022, every 15 minutes") +
  scale_x_continuous(name = "Time between 8h and 21h each day",
                     breaks = c(0,50,100,150,200,250,300,350,400,450))
```

### Only reliable data

```{r}
#Load data
reliable_data_8h_21h_04_to_12_07_2022 <- data_8h_21h_04_to_12_07_2022 %>% 
           #if only 1 prediction : keep only data with a confidence >= 0.34
  filter((number_of_predictions == 1 & confidence >= 0.34) | 
           #if >1 predictions : keep only data with  a confidence >= 0.34 & a gap >0.2 between the 2 best predictions' confidences
           (number_of_predictions >1 & confidence >= 0.34 & confidence_gap >= 0.2) |
           #keep the NA values also
           is.na(confidence_gap))

# Changes per 15minutes & per day
amount_changes_data_8h_21h_04_to_12_07_2022_reliable_data <- amount_posture_changes(reliable_data_8h_21h_04_to_12_07_2022, "15 minute")

# Skip parts between 21h and 8h
amount_changes_data_8h_21h_04_to_12_07_2022_compressed_time_reliable_data <- add_compressed_time_variable(amount_changes_data_8h_21h_04_to_12_07_2022_reliable_data)

# Plot
ggplot(amount_changes_data_8h_21h_04_to_12_07_2022_compressed_time_reliable_data,
       aes(x = compressed_time, y = Nb_changes)) +
  
  geom_rect(data = areas, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf, fill = fill),
            inherit.aes = FALSE, alpha = 0.2) +
  
  geom_line() +
  #xlab("Temps entre 8h et 21h chaque jour") +
  ylab("Amount of posture changes") +
  ggtitle("Posture changes of fox 4313", subtitle = "Only reliable data, from 04/07/2022 to 12/07/2022, every 15 minutes") +
  scale_x_continuous(name = "Time between 8h and 21h each day",
                     breaks = c(0,50,100,150,200,250,300,350,400,450))
```
